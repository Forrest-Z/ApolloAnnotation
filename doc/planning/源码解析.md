# 源码解析

## 类图

```mermaid
classDiagram


class PlanningComponent{
	traffic_light_reader_
	routing_reader_
	pad_msg_reader_
	relative_map_reader_
	story_telling_reader_
	planning_writer_
	rerouting_writer_
	planning_learning_data_writer_
	
	traffic_light_
	routing_
	pad_msg_
	relative_map_
	stories_
	local_view_
	planning_base_
	injector_
	message_process_
	
	+Proc(prediction_obstacles,chassis,localization_estimate)
}


PlanningComponent*--TrafficLightDetection
class TrafficLightDetection{
	
}

PlanningComponent*--DependencyInjector
class DependencyInjector{
	
}


PlanningComponent*--PlanningBase
class PlanningBase{
	<<interface>>
	local_view_
	hdmap_
	frame_
	planner_
	last_publishable_trajectory_
	planner_dispatcher_
	injector_
}

PlanningComponent*--MessageProcess
class MessageProcess{
	
}
```

```mermaid
classDiagram

class PlanningBase{
	<<interface>>
	local_view_
	hdmap_
	frame_
	planner_
	last_publishable_trajectory_
	planner_dispatcher_
	injector_
	-Init(config)
	+RunOnce(local_view,ptr_trajectory_pb)
}

PlanningBase*--PlannerDispatcher
class PlannerDispatcher{
	<<interface>>
}


PlanningBase*--Planner
class Planner{
	<<interface>>
	scenario_manager_
	scenario_
	+Plan(planning_init_point,frame,ptr_computed_trajectory) 
}


PlanningBase*--PublishableTrajectory
class PublishableTrajectory{
	
}

PlanningBase*--DependencyInjector
class DependencyInjector{
	planning_context_
	frame_history_
	history_
	ego_info_
	vehicle_state_
	learning_based_data_
}

PlanningBase..TaskFactory
class TaskFactory{
	
}
```







```mermaid
classDiagram

class PlanningBase{
	<<interface>>
	local_view_
	hdmap_
	frame_
	planner_
	last_publishable_trajectory_
	planner_dispatcher_
	injector_
}

PlanningBase<--OnLanePlanning
class OnLanePlanning{
	last_routing_
	reference_line_provider_
	planning_smoother_
	+RunOnce(local_view,ptr_trajectory_pb)
}

PlanningBase<--NaviPlanning
class NaviPlanning{
	
}

```









```mermaid
classDiagram

class Planner{
	<<interface>>
	scenario_manager_
	scenario_
	+Plan(planning_init_point,frame,ptr_computed_trajectory) 
}

Planner<--PlannerWithReferenceLine
class PlannerWithReferenceLine{
	<<interface>>
	+Plan(planning_init_point,frame,ptr_computed_trajectory) 
}

PlannerWithReferenceLine<--PublicRoadPlanner
class PublicRoadPlanner{
	+Plan(planning_init_point,frame,ptr_computed_trajectory) 
}

PlannerWithReferenceLine<--NaviPlanner
class NaviPlanner{
	+Plan(planning_init_point,frame,ptr_computed_trajectory) 
}

PlannerWithReferenceLine<--RTKReplayPlanner
class RTKReplayPlanner{
	+Plan(planning_init_point,frame,ptr_computed_trajectory) 
}

PlannerWithReferenceLine<--LatticePlanner
class LatticePlanner{
	+Plan(planning_init_point,frame,ptr_computed_trajectory) 
}

```









```mermaid
classDiagram

class DependencyInjector{
	planning_context_
	frame_history_
	history_
	ego_info_
	vehicle_state_
	learning_based_data_
}

DependencyInjector*--PlanningContext
class PlanningContext{
	
}

DependencyInjector*--EgoInfo
class EgoInfo{
	
}

DependencyInjector*--FrameHistory
class FrameHistory{
	
}

DependencyInjector*--History
class History{
	
}

DependencyInjector*--VehicleStateProvider
class VehicleStateProvider{
	
}

DependencyInjector*--LearningBasedData
class LearningBasedData{
	
}

 
```

```mermaid
classDiagram

class TaskFactory{
	task_factory_
	default_task_configs_
}
```

```mermaid
classDiagram

class ScenarioManager{
	injector_;
  planning_config_;
  config_map_;
  current_scenario_;
  default_scenario_type_;
  scenario_context_;
  first_encountered_overlap_map_;
}

ScenarioManager*--Scenario
class Scenario{
  scenario_status_;
  current_stage_;
  config_;
  stage_config_map_;
  scenario_context_;
  name_;
  msg_;
  injector_;
}

Scenario*--ScenarioStatus
class ScenarioStatus{
	
}

Scenario*--Stage
class Stage{
	
}

Scenario*--ScenarioConfig
class ScenarioConfig{
	
}

Scenario*--ScenarioContext
class ScenarioContext{
	
}

Scenario*--DependencyInjector
class DependencyInjector{
	
}
```





## 源码

**PlanningComponent模块**的入口为modules/planning/planning_component.cc

对应的配置dag文件：

```json
```





PlanningComponent模块会订阅topic：`"/apollo/routing_response"`

该topic由Routing模块发布，`RoutingResponse`是Routing模块生成的路径

```c++
 //  routing_response_topic: "/apollo/routing_response"
  routing_reader_ = node_->CreateReader<RoutingResponse>(
      config_.topic_config().routing_response_topic(),
      [this](const std::shared_ptr<RoutingResponse>& routing) {
        AINFO << "Received routing data: run routing callback."
              << routing->header().DebugString();
        std::lock_guard<std::mutex> lock(mutex_);
        routing_.CopyFrom(*routing);
      });

```

`RoutingResponse`保存着Routing模块生成的路径

在文件`modules/routing/proto/routing.proto` 中定义

```protobuf
message RoutingResponse {
  optional apollo.common.Header header = 1;
  repeated RoadSegment road = 2;
  optional Measurement measurement = 3;
  optional RoutingRequest routing_request = 4;

  // the map version which is used to build road graph
  optional bytes map_version = 5;
  optional apollo.common.StatusPb status = 6;
}
```



